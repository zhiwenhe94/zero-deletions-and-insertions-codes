//------------------------Verification construction V.1----------------------------------
t:=3;
D:=4;//You can set different D to verify. Note that D is even.
w:=5;

Ytw:=function(t,w,D);
Ytws:={};
d:=14;
for x0,x1,x2,x3,x4,xw in [0..d] do 
     if x0 mod D eq 0 and x1 mod D eq 0 and x2 mod D eq 0 and x3 mod D eq 0 and x4 mod D eq 0 and x0+x1+x2+x3+x4+xw eq t*D+D/2 then Ytws join:={[x0,x1,x2,x3,x4,xw]};end if;
end for;
return Ytws;
end function;


Ei:=function(t,D);
Eis:={};
for xi,xi1,xi2 in [0..t] do 
     if xi+xi1+xi2 eq t then Eis join:={[xi*D,xi1*D,xi2*D]};end if;
end for;
return Eis;
end function;

Eih:=function(Eis,D);
Eihs:={};
for y in Eis do 
    x:=[0,0,0,0,0,0];
    x[1]:=y[1];
    x[2]:=y[2];
    x[3]:=y[3];
    x[6]:=D/2;
   Eihs join:={x};
end for;
for y in Eis do 
    x:=[0,0,0,0,0,0];
    x[4]:=y[1];
    x[5]:=y[2];
    x[6]:=y[3]+D/2;
   Eihs join:={x};
end for;
return Eihs;
end function;


Eb:=function(Ytws,D)
Eis:=Ei(t,D);
Ebs:=Ytws diff Eih(Eis,D);
return Ebs;
end function;

Eib:=function(Eis,Eips,i);
Eibs:={};
for y in Eis do 
x:=[0,0,0,0,0,0];
for j in [1..3] do 
     x[i+j]:=y[j];
end for ;
Eibs join:={x};
end for;
for y in Eips do 
x:=[0,0,0,0,0,0];
for j in [1..3] do 
     x[i+j]:=y[j];
end for ;
Eibs join:={x};
end for;
return Eibs;
end function;

OPEi:=function(Eis,t,D);
OPEis:={};
s:=0;
if t mod 3 eq 0 then s:=0;end if;
if t mod 3 eq 1 then s:=2;end if;
if t mod 3 eq 2 then s:=1;end if;
for x in Eis do 
I1:=[D/2,0,0];
I2:=[0,D/2,0];
I0:=[0,0,D/2];
d:=IntegerRing()!(2*x[1]/D+x[3]/D+s);
if d mod 3 eq 0 then 
    OPEis join:={[x[1]+I0[1],x[2]+I0[2],x[3]+I0[3]]};
end if;
if d mod 3 eq 1 then 
    OPEis join:={[x[1]+I1[1],x[2]+I1[2],x[3]+I1[3]]};
end if;
if d mod 3 eq 2 then 
    OPEis join:={[x[1]+I2[1],x[2]+I2[2],x[3]+I2[3]]};
end if;
end for;
return OPEis;
end function;

Eip:=function(t,D);
Eips:={};
for y0,y1,y2 in [0..t-1] do 
     if y0-y1 mod 3 eq 0 and y0+y1+y2 eq t-1 then Eips join:={[y0*D+D/2,y1*D+D/2,y2*D+D/2]};end if;
end for;
return Eips;
end function;

Atw:=function(t,w,D);
Ytws:=Ytw(t,w,D);
Atws:=Eb(Ytws,D);
Eis:=Ei(t,D);
Eips:=Eip(t,D);
OPEis:=OPEi(Eis,t,D);
al:=0;
if w mod 3 eq 2 then al:=w-2;end if;
if w mod 3 eq 0 then al:=w-3;end if;
if w mod 3 eq 1 then al:=w-4;end if;
for i in [0..al] do 
      if i mod 3 eq 0 then 
      Atws:=Atws join Eib(OPEis,Eips,i);
      end if;
end for;
return Atws;
end function;


// check the minimum distance of Bt7(Y) 
MAX:=function(S);
ymax:=0;
for y in S do 
    if y ge ymax then ymax:=y;end if;
end for;
return ymax;
end function;

DisCk:=function(A);
ck:=1;
for x,y in A do 
     if x ne y then 
        Ds:={};
         for i in [1..6] do 
              Ds join:={Abs(x[i]-y[i])};
         end for;
        if MAX(Ds) le D-1 then ck:=0;print x,y;break;end if;
     end if;
end for;
return ck;
end function;

Atws:=Atw(t,w,D);
if DisCk(Atws) eq 1 then print "The code Atws has minimum distance >=D.";end if;


//check constant weight
WeiCk:=function(Atws);
W:={};
for y in Atws do 
     ys:=0;
     for i in [1..6] do 
          ys:=ys+y[i];
     end for;
    W join:={ys};
end for;
if #W eq 1 then return Random(W);else return 0;end if;
end function;
WeiCk(Atws);


//check the number result in Theorem V.2
SizCk:=function(t,Atws);
Ck:=0;
Atwsize:=0;
if Binomial(t+1,2) mod 3 eq 0 then 
    if (w+1) mod 3 eq 0 then  
    Atwsize:=Binomial(t+1,2)/3*(w+1)/3+Binomial(t+w,w);
   else 
    Atwsize:=Binomial(t+1,2)/3*(w+1-((w+1) mod 3))/3+Binomial(t+w,w);   
   end if;
else 
    if (w+1) mod 3 eq 0 then  
   Atwsize:=((Binomial(t+1,2)-(Binomial(t+1,2) mod 3))/3+1)*(w+1)/3+Binomial(t+w,w); 
    else 
   Atwsize:=((Binomial(t+1,2)-(Binomial(t+1,2) mod 3))/3+1)*(w+1-((w+1) mod 3))/3+Binomial(t+w,w); 
   end if;
end if;
if #Atws eq Atwsize then Ck:=1;end if;
return Ck;
end function;

if SizCk(t,Atws) eq 1 then print "the results about the size in Theorem V.2 are correct.";end if;

